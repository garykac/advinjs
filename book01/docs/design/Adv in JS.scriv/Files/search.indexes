<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<SearchIndexes Version="1.0">
    <Documents>
        <Document ID="102">
            <Title>137 level 2-3 - image</Title>
            <Text>change goal based on whether or not the player has the key


TITLE = Keys for level 2 and 3
ID = 137


B: We can add a key to level 2

BEGIN_CODE
.function init_level2() {
.	...
.	add_default_platforms(level);
.
+	var items = [
+		[250, 360, 18, 20, "key", "key"],
+	];
+	add_items(level, items);
+
.	level.goal = create_goal(500, 360, 2);
.	...
.}
END_CODE

B: Rather than add a key to level 3 (which would just allow us to loop back to level 1 in any case), we can add a new item that ends the game when you acquire it.


B: Create 1 bitmap: items/gem.png

COPY_FILE images/items/gem.png


BEGIN_CODE
.function init_level3() {
.	...
.	add_default_platforms(level);
.
+	var items = [
+		[500, 360, 21, 27, "finish", "gem"],
+	];
+	add_items(level, items);
+
.	level.goal = create_goal(500, 360, 0);
.	
.	_levels.push(level);
.}
END_CODE


B: Note that you the goal doesn't indicate whether or not it is currently locked. We'll can fix that now.


GOTO 140 IF_BADGE Platform III - Pattern

GOTO 138
</Text>
        </Document>
        <Document ID="11">
            <Title>B00 - baseline</Title>
            <Text>This is the simple webpage with a canvas on it and a blue square that you can move around with the keyboard.</Text>
        </Document>
        <Document ID="98">
            <Title>133 item draw - image</Title>
            <Text>


draw key image



load image


function init_game() {
	...
	_game.imagedir_monsters = _game.imagedir + "monsters/";
	_game.imagedir_items = _game.imagedir + "items/";
	...
}


fdfdas

fda
function init_level1() {
	...
	add_monsters(level, monst);

	var items = [
		[480, 110, 20, 20, "key", "key"],
	];
	add_items(level, items);

	level.goal = create_goal(35, 190, 2);
	
	_levels.push(level);
}

fasfdsafsf


function create_monster(x, y, width, height, min_x, max_x, move_x, images) {
	...
}

// item_data: [x, y, width, height, type, image]
function add_items(level, item_data) {
	for (var i = 0; i &lt; item_data.length; i++) {
		var d = item_data[i];
		var item = create_item(d[0], d[1], d[2], d[3], d[4], d[5]);
		level.items.push(item);
	}
}

function create_item(x, y, width, height, type, image) {
	var d = {};
	d.x = x;
	d.y = y;
	d.width = width;
	d.height = height;
	d.origin_x = width / 2;
	d.origin_y = height;
	d.type = type;
	d.found = false;
	d.img = new Image();
	d.img.src = _game.imagedir_items + image + ".png";
	return d;
}

function create_goal(x, y, next_level) {
	...
}


Note that d.found is set to false. We'll set this to true so that we know when the item has been found by the player.
fsdafdds

Just having the items on the level isn't enough we need to draw and collide with them.
Nothing will happen 


run verify. code is the same as before.


fdafd

function draw() {
	...
	erase(ctx);
	draw_platforms(ctx);
	draw_monsters(ctx);
	draw_items(ctx);
	draw_goal(ctx);
	draw_player(ctx);
	...
}


fdafd


function draw_monsters(ctx) {
	...
}

function draw_items(ctx) {
	var level = _levels[_game.current_level];
	var items = level.items;
	for (var i = 0; i &lt; items.length; i++) {
		var t = items[i];
		if (!t.found) {
			ctx.drawImage(t.img, t.x, t.y);
		}
	}
}

function draw_goal(ctx) {
	...
}


ffdasfd


**** if status bar, then draw there as well
GOTO 139 IF_BADGE Vitality I - Health




GOTO 134
</Text>
        </Document>
        <Document ID="110">
            <Title>180 Health</Title>
            <Text>Add player health  (this adds status bar)



fdafdsa


function init_player() {
	...
	_player.origin_x = 0;
	_player.origin_y = 0;

	_player.health_max = 50;
	_player.health = _player.health_max;
	_player.is_jumping = false;
	...
}

fdafdasfad


function start_level(level_id) {
	...
}

function adjust_health(amount) {
	_player.health += amount;
	if (_player.health &lt;= 0) {
		_player.health = 0;
		_game.game_over = true;
	}
	if (_player.health > _player.health_max) {
		_player.health = _player.health_max;
	}
}

fdfds



function check_monster_collisions() {
	var level = _levels[_game.current_level];
	var monsters = level.monsters;
	var damage = 0;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		if (collide(m, _player)) {
			_game.game_over = true;
			damage++;
		}
	}
	if (damage != 0) {
		adjust_health(-damage);
	}
}


fdafdsaf

you have health, but you can't see how much.

let's add a health meter at the top of the screen to track our current health.


IF you have sprites:

fdafdas

function update_player_sprite() {
	var sprite;
	if (_player.health &lt;= 0) {
		sprite = _player.sprite_sad;
	} else if (_player.x &lt;= (_game.meter_x + _game.meter_width)
				&amp;&amp; _player.y &lt;= (_game.meter_y + _game.meter_height + 20)) {
		sprite = _player.sprite_glasses;
	} else if (_game.game_win) {
		sprite = _player.sprite_happy;
	} else if (_player.is_touching_monster) {
		sprite = _player.sprite_ooo;
	} else {
		sprite = _player.sprite;
	}

	// Update the player width, height and origin based on the current sprite.
	_player.width = sprite.width;
	_player.height = sprite.height;
	_player.origin_x = sprite.origin_x;
	_player.origin_y = sprite.origin_y;
	
	return sprite;
}


fdasfd


GOTO 100
</Text>
        </Document>
        <Document ID="55">
            <Title>045 Add collide()</Title>
            <Text>

df




function check_goal_collisions() {
	...
}

// Return true if the 2 objects overlap.
function collide(obj1, obj2) {
	if ((obj1.x - obj1.origin_x + obj1.width) &lt;= (obj2.x - obj2.origin_x))
		return false;
	if ((obj1.y - obj1.origin_y + obj1.height) &lt;= (obj2.y - obj2.origin_y))
		return false;
	if ((obj2.x - obj2.origin_x + obj2.width) &lt;= (obj1.x - obj1.origin_x))
		return false;
	if ((obj2.y - obj2.origin_y + obj2.height) &lt;= (obj1.y - obj1.origin_y))
		return false;
	
	return true;
}

// This is called ~60 times per second to update the world.
function update_world() {
	...
}


fdasfds

IF you have your "Movement III - Jump" badge
	GOTO 046

GOTO 044</Text>
        </Document>
        <Document ID="12">
            <Title>000 Intro</Title>
            <Text>We're starting in the middle of the story - after the reader's character has been introduced to the teacher and has already created the "baseline" game.

This baseline game is just a very simple set of HTML + CSS + JS files (one each) that initializes a canvas (where the game will take place) and allows a small blue rectangle (representing the player) to be moved around the screen.

For now, you should download the following files to catchup with the story:
	script.js
	game.html
	style.css
And copy them into a brand new directory in your projects folder.

Also, print out your character sheet and mark down the following badges and skills, which you've already (supposedly) learned in the earlier part of the story:
***


Balance between the good programming practices and the easiest to understand code.


This is not a dangerous adventure. There is no need to be concerned about making poor choices and not reaching the end. There are no bad paths or dead ends, and you can alway follow the paths marked with a *** to navigate through the adventure.


There's a "map" of the functions that you'll be adding.

ellipses will be used to indicate where code is skipped.

efficiently switching between the text editor and the browser

using the browser inspector and console.log lines.
</Text>
        </Document>
        <Document ID="99">
            <Title>134 Item collide</Title>
            <Text>To make player collide with item

function check_collisions() {
	check_platform_collisions();
	check_monster_collisions();
	check_item_collisions();
	check_goal_collisions();
}

fdasfdsaf

function check_monster_collisions() {
	...
}

function check_item_collisions() {
	var level = _levels[_game.current_level];
	var items = level.items;
	for (var i = 0; i &lt; items.length; i++) {
		var item = items[i];
		if (!item.found) {
			if (collide(item, _player)) {
				item.found = true;
			}
		}
	}
}

function check_goal_collisions() {
	...
}

Run your code

Now the item will disappear once the player touches it.

fdasfd

GOTO 135</Text>
        </Document>
        <Document ID="56">
            <Title>050 Next</Title>
            <Text>Before we can go further, we need to talk about arrays.

*** TODO info about arrays

var platform = {};
platform.x = 0;

var platforms = [];
platforms.push({});
platforms[0].x = 0;

GOTO 051

</Text>
        </Document>
        <Document ID="103">
            <Title>138 finish</Title>
            <Text>fdsafdsa

function check_item_collisions() {
	var level = _levels[_game.current_level];
	var items = level.items;
	for (var i = 0; i &lt; items.length; i++) {
		var item = items[i];
		if (!item.found) {
			if (collide(item, _player)) {
				if (item.type == "key") {
					level.player_has_key = true;
				} else if (item.type == "finish") {
					_game.game_over = true;
					_game.game_win = true;
				}
				item.found = true;
			}
		}
	}
}


Gain the "Treasure II - Finish" badge

fdsafdsa

GOTO 100
</Text>
        </Document>
        <Document ID="13">
            <Title>Files and Folders</Title>
            <Text>How to organize your files and projects

folders = directories
</Text>
        </Document>
        <Document ID="111">
            <Title>190 Multiple lives</Title>
            <Text>Add player multiple lives



GOTO 100</Text>
        </Document>
        <Document ID="57">
            <Title>Stage 0</Title>
        </Document>
        <Document ID="80">
            <Title>081</Title>
            <Text>fdafda

	_game.platforms = [];
	// The bottom brick platform along the bottom of the stage.
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	// The left offstage 'wall' to keep the player on the stage.
	_game.platforms.push(
		create_platform(-60, -_game.height, 60, 2 * _game.height));
	// The right offstage 'wall' to keep the player on the stage.
	_game.platforms.push(
		create_platform(_game.width, -_game.height, 60, 2 * _game.height));
	_game.platforms.push(create_platform(200, 290, 80, 20));
	_game.platforms.push(create_platform(300, 240, 80, 20));
	_game.platforms.push(create_platform(400, 170, 80, 20));
	_game.platforms.push(create_platform(460, 110, 40, 20));

Pay attention: Note that -_game.height looks a bit weird because of the negative sign next to the underscore in _game.



RUN the code
Note that the player now stays completely on the screen since it's colliding with a tall platform just offscreen.

GOTO 090
</Text>
        </Document>
        <Document ID="14">
            <Title>script.js</Title>
            <Text>// Global variables
var _game = {};
var _player = {};	

function setup() {
	window.addEventListener("load", handle_load, false);
	window.addEventListener("keydown", handle_keydown, false);
	window.addEventListener("keyup", handle_keyup, false);
}

// Handle the load event (which is sent when the page has finished loading).
function handle_load(event) {
	init();
	requestAnimationFrame(update_world);
}

function handle_keydown(event) {
	_game.keymap[event.keyCode] = true;
}

function handle_keyup(event) {
	_game.keymap[event.keyCode] = false;
}

// Initialize the game state.
function init() {
	init_game();
	init_player();
}

// Initialize general game state info.
function init_game() {
	var canvas = document.getElementById("stage");
	canvas.width = 550;
	canvas.height = 400;
	
	_game.width = canvas.width;
	_game.height = canvas.height;
	
	// The keymap keeps track of which keys are currently being pressed.
	_game.keymap = {};
}

// Initialize player data.
function init_player() {
	_player.x = 0;
	_player.y = 0;
	_player.width = 20;
	_player.height = 20;

	_player.velocity_x = 0;
	_player.velocity_y = 0;
}

// Erase the stage and draw all the objects.
function draw() {
	var canvas = document.getElementById("stage");
	var ctx = canvas.getContext("2d");

	erase(ctx);
	draw_player(ctx);
}

// Erase the stage by filling it with white.
function erase(ctx) {
	ctx.fillStyle = "#ffffff";
	ctx.fillRect(0, 0, _game.width, _game.height);
}

// Draw the player.
function draw_player(ctx) {
	ctx.fillStyle = "blue";
	ctx.fillRect(_player.x, _player.y, _player.width, _player.height);
}

// Handle input and move the player.
function update_player() {
	check_input();
	
	// Move the player to the new location.
	_player.x += _player.velocity_x;
	_player.y += _player.velocity_y;
}

function check_input() {
	_player.velocity_x = 0;
	_player.velocity_y = 0;
	
	// Left arrow or 'a' to move left.
	if (_game.keymap[37] || _game.keymap[65]) {
		_player.velocity_x = -1;
	}
	// Right arrow or 'd' to move right.
	if (_game.keymap[39] || _game.keymap[68]) {
		_player.velocity_x = 1;
	}
	// Up arrow or 'w' to move up.
	if (_game.keymap[38] || _game.keymap[87]) {
		_player.velocity_y = -1;
	}
	// Down arrow or 's' to move up.
	if (_game.keymap[40] || _game.keymap[83]) {
		_player.velocity_y = 1;
	}
}

// This is called ~60 times per second to update the world.
function update_world() {
	update_player();
	draw();
	
	requestAnimationFrame(update_world);
}

setup();
</Text>
        </Document>
        <Document ID="104">
            <Title>120 Player images</Title>
            <Text>Use bitmap images for the player


Create the images/player directory.

Create 3 icons:
	player/happy.png
	player/normal.png
	player/sad.png



function init_game() {
	...
	// The keymap keeps track of which keys are currently being pressed.
	_game.keymap = {};

	_game.imagedir = "images/";
	_game.imagedir_player = _game.imagedir + "player/";

	// Game state.
	_game.game_over = false;
	...
}


fdas


function init_player() {
	// Player x,y are initialized by the level.
	_player.x = 0;
	_player.y = 0;
	
	// Player width,height and origin are initialized by the current sprite.
	_player.width = 20;
	_player.width = 0;
	_player.height = 20;
	_player.height = 0;
	_player.origin_x = _player.width / 2;
	_player.origin_x = 0;
	_player.origin_y = _player.height;
	_player.origin_y = 0;

	_player.is_jumping = false;
	
	_player.velocity_x = 0;
	_player.velocity_x_delta = 0.8;
	_player.velocity_x_max = 3.5;
	_player.velocity_y = 0;
	_player.velocity_y_jump = -10;
	_player.velocity_y_max = 10;

	_player.sprite = init_player_sprite("normal", 20, 24);
	_player.sprite_sad = init_player_sprite("sad", 30, 17);
	_player.sprite_happy = init_player_sprite("happy", 20, 24);
	update_player_sprite();
}

function init_player_sprite(name, width, height, origin_x, origin_y) {
	var sprite = {};
	sprite.width = width;
	sprite.height = height;
	sprite.origin_x = width / 2;
	sprite.origin_y = height;
	sprite.img = new Image();
	sprite.img.src = _game.imagedir_player + name + ".png";
	return sprite;
}

function update_player_sprite() {
	var sprite;
	if (_game.game_over &amp;&amp; !_game.game_win) {
		sprite = _player.sprite_sad;
	} else if (_game.game_win) {
		sprite = _player.sprite_happy;
	} else {
		sprite = _player.sprite;
	}

	// Update the player width, height and origin based on the current sprite.
	_player.width = sprite.width;
	_player.height = sprite.height;
	_player.origin_x = sprite.origin_x;
	_player.origin_y = sprite.origin_y;
	
	return sprite;
}

function init_level_defaults(level) {
	...
}

and now replace draw_player to use update_player_sprite just before we draw it.

function draw_player(ctx) {
	ctx.fillStyle = "blue";
	ctx.fillRect(_player.x - _player.origin_x, _player.y - _player.origin_y,
					_player.width, _player.height);
	var sprite = update_player_sprite();
	ctx.drawImage(sprite.img, _player.x - _player.origin_x,
					_player.y - _player.origin_y);
}



GOTO 121

</Text>
        </Document>
        <Document ID="58">
            <Title>Stage 1</Title>
        </Document>
        <Document ID="81">
            <Title>063 init monsters (1st)</Title>
            <Text>in init_game():

	// Game state.
	_game.game_over = false;
	_game.platform = create_platform(0, 360, _game.width, 40);
	_game.monsters = [];
	_game.monsters.push(create_monster(350, 360, 20, 20));
	_game.goal = create_goal(500, 360);

fdafdsa



GOTO 065</Text>
        </Document>
        <Document ID="15">
            <Title>game.html</Title>
            <Text>&lt;html>
&lt;head>
	&lt;title>Canvas Game&lt;/title>

	&lt;link rel="stylesheet" type="text/css" href="style.css" />
	&lt;script type='text/javascript' src="script.js">&lt;/script>
&lt;/head>

&lt;body>

&lt;canvas id="stage">&lt;/canvas>

&lt;/body>
&lt;/html>
</Text>
        </Document>
        <Document ID="112">
            <Title>049</Title>
            <Text>Finish this state

GOTO 050
</Text>
        </Document>
        <Document ID="59">
            <Title>Stage 2</Title>
        </Document>
        <Document ID="82">
            <Title>064 init monsters (2nd)</Title>
            <Text>in init_game():

	// Game state.
	_game.game_over = false;
	_game.platforms = [];
	...
	_game.platforms.push(create_platform(400, 170, 80, 20));
	_game.platforms.push(create_platform(460, 110, 40, 20));
	_game.monsters = [];
	_game.monsters.push(create_monster(350, 360, 20, 20));
	_game.goal = create_goal(500, 360);

fdafdsa

GOTO 065</Text>
        </Document>
        <Document ID="16">
            <Title>style.css</Title>
            <Text>body {
	background-color: blue;
	color: white;
}

canvas {
	border: 1px solid black;
}
</Text>
        </Document>
        <Document ID="105">
            <Title>111 Platform pattern</Title>
            <Text>Use bitmap images for the platforms



Create the images/backgrounds directory.

Create 3 icons:
	backgrounds/block.png
	backgrounds/brick.png
	backgrounds/dirt.png


fdsafasd

function init_game() {
	...
	_game.imagedir = "images/";
	_game.imagedir_player = _game.imagedir + "player/";
	_game.imagedir_monsters = _game.imagedir + "monsters/";
	_game.imagedir_backgrounds = _game.imagedir + "backgrounds/";
	...
}


fdafdsa

function init_level1() {
	...
	add_default_platforms(level);
	var platform_data = [
		[200, 290, 80, 20],
		[200, 290, 80, 20, "dirt"],
		[300, 240, 80, 20],
		[300, 240, 80, 20, "block"],
		[400, 170, 80, 20],
		[400, 170, 80, 20, "block"],
		[460, 110, 40, 20],
		[460, 110, 40, 20, "dirt"],
	];
	add_platforms(level, platform_data);
	...
}

fdafd

The default platforms need to be updated as well

function add_default_platforms(level) {
	var platform_data = [
		// The bottom brick platform along the bottom of the stage.
		[0, 360, _game.width, 40],
		[0, 360, _game.width, 40, "brick"],
		// The left offstage 'wall' to keep the player on the stage.
		[-60, -_game.height, 60, 2*_game.height],
		[-60, -_game.height, 60, 2*_game.height, "#000000"],
		// The right offstage 'wall' to keep the player on the stage.
		[_game.width, -_game.height, 60, 2*_game.height],
		[_game.width, -_game.height, 60, 2*_game.height, "#000000"],
	];
	add_platforms(level, platform_data);
}

fdasfdsa

// platform_data: [x, y, width, height]
// platform_data: [x, y, width, height, pattern]
function add_platforms(level, platform_data) {
	for (var i = 0; i &lt; platform_data.length; i++) {
		var p = platform_data[i];
		var plat = create_platform(p[0], p[1], p[2], p[3]);
		var plat = create_platform(p[0], p[1], p[2], p[3], p[4]);
		level.platforms.push(plat);
	}
}


fadsfads

function create_platform(x, y, width, height) {
function create_platform(x, y, width, height, pattern) {
	var p = {};
	p.x = x;
	p.y = y;
	p.width = width;
	p.height = height;
	p.origin_x = 0;
	p.origin_y = 0;	

	// If pattern begins with '#' then it's really a background color.
	if (pattern.charAt(0) == '#') {
		p.background_color = pattern;
	} else {
		p.pattern = new Image();
		p.pattern.src = _game.imagedir_backgrounds + pattern + ".png";
	}
	
	return p;
}



fdfads

function set_transform_xy(ctx, x, y) {
	// Translate origin to (x,y).
	ctx.setTransform(1, 0, 0, 1, x, y);
}

function set_transform(ctx, obj) {
	...
}



fdasfdsafs


function draw_platforms(ctx) {
	var level = _levels[_game.current_level];
	var platforms = level.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		var platform = platforms[i];
		ctx.fillStyle = "green";
		ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

		if (p.background_color) {
			ctx.fillStyle = p.background_color;
			ctx.fillRect(p.x, p.y, p.width, p.height);
			ctx.strokeStyle = "rgba(0,0,0,0.5)";
			ctx.strokeRect(p.x, p.y, p.width, p.height);
		} else {
			var pat = ctx.createPattern(p.pattern, "repeat");
			set_transform_xy(ctx, p.x, p.y);
			ctx.fillStyle = pat;
			ctx.fillRect(0, 0, p.width, p.height);
			reset_transform(ctx);
		}
	}
}


fdsafdsa

GOTO 100
</Text>
        </Document>
        <Document ID="83">
            <Title>065 init monsters2</Title>
            <Text>

To add monsters:

function create_platform(x, y, width, height) {
	...
}

function create_monster(x, y, width, height) {
	var m = {};
	m.x = x;
	m.y = y;
	m.width = width;
	m.height = height;
	m.origin_x = m.width / 2;
	m.origin_y = m.height;
	return m;
}

function create_goal(x, y) {
	...
}


fdsfsd


function draw_platforms(ctx) {
	...
}

function draw_monsters(ctx) {
	var monsters = _game.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		ctx.fillStyle = "#800000";
		ctx.fillRect(m.x - m.origin_x, m.y - m.origin_y, m.width, m.height);
	}
}

function draw_goal(ctx) {
	...
}


fdafd

in the draw() function:

	erase(ctx);
	draw_platforms(ctx);
	draw_monsters(ctx);
	draw_goal(ctx);
	draw_player(ctx);

fdafd


GOTO 056
</Text>
        </Document>
        <Document ID="113">
            <Title>046 Use collide (jump merge)</Title>
            <Text>Now that we have this nifty collide() function, we can use it for our platform collisions as well.

function check_platform_collisions() {
	if (_player.y > _game.platform.y) {
	if (collide(_game.platform, _player)) {
		_player.is_jumping = false;
		_player.y = _game.platform.y;
		_player.velocity_y = 0;
	}
}


GOTO 044
</Text>
        </Document>
        <Document ID="17">
            <Title>xxx Title screen</Title>
            <Text>doesn't have a goal
	we can handle by giving it a goal (offscreen), or by checking each level for a goal.</Text>
        </Document>
        <Document ID="40">
            <Title>027 Jumping (after Goal)</Title>
            <Text>(already have collision code from goal)



function check_collisions() {
	check_platform_collisions();
	check_goal_collisions();
}

function check_platform_collisions() {
	if (collide(_game.platform, _player)) {
		_player.y = _game.platform.y;
		_player.velocity_y = 0;
	}
}

function check_goal_collisions() {
	...
}



RUN your code in a browser and verify that it loads without errors.

GOTO 028

</Text>
        </Document>
        <Document ID="84">
            <Title>To do</Title>
            <Text>Add backtrack links when the player cannot compile/confirm on the same page

Add "if you run now, you see XXX error"

Add Level 1 message between stages.


Add a walkthrough for people who don't want to manage a character sheet</Text>
        </Document>
        <Document ID="106">
            <Title>115 Image direction</Title>
        </Document>
        <Document ID="18">
            <Title>xxx Breaking into multiple files</Title>
            <Text>One large file. unwieldy

We can break it up, but how?

One obvious candidate is the level initialization functions. they're big.
	Each level could be its own file, or they could all be in one levels.js file

We could also have all the drawing-related functions in a draw.js

Or we could move all the player related functions into player.js

Where would we put draw_player()?

cf. object-oriented programming.

Each level could be in a separate file, that would make it easier for multiple people to work on the game without interfering with each other - as long as they worked on separate levels.

"Ooo.. that way I could get someone to do part of my homework for me. Sounds good to me."

"Hmm. Good point. Perhaps we should skip breaking up the levels for now."
</Text>
        </Document>
        <Document ID="41">
            <Title>008</Title>
            <Synopsis>GOTO 015
GOOT 010
</Synopsis>
            <Text>IF you have the "Movement I" badge
	THEN GOTO 015
	ELSE GOTO 010
</Text>
        </Document>
        <Document ID="114">
            <Title>089</Title>
            <Text>Finish stage

GOTO 090
</Text>
        </Document>
        <Document ID="85">
            <Title>092 Adding a second level</Title>
            <Text>Now that level 1 has been cleaned up, it's easy to add more levels.

function init_level1() {
	...
}

function init_level2() {
	var level = {};
	init_level_defaults(level);

	level.player_start_x = 20;
	level.player_start_y = 260;

	add_default_platforms(level);

	level.goal = create_goal(500, 360);
	
	_levels.push(level);
}

function init_level3() {
	var level = {};
	init_level_defaults(level);

	level.player_start_x = 20;
	level.player_start_y = 260;

	add_default_platforms(level);

	level.goal = create_goal(500, 360);
	
	_levels.push(level);
}

// platform_data: [x, y, width, height]
function add_platforms(level, platform_data) {
	...
}

These are basically empty placeholder levels at the moment. We'll be fleshing them out later. For now, we just want to get these levels hooked up and then finish up level 1.

fdads

// Initialize the game state.
function init() {
	init_game();
	init_player();
	init_level1();
	init_level2();
	init_level3();
}

fdafd

YOU: If we're going to leave them empty, why'd we bother creating them now?

B: So that we have the structure and framework in place. If we plow ahead with level 1 now, we'll have to make lots of tiny changes later when we want to add new levels. By adding this framework now, when we're ready to work on the other levels, we'll be able to start immediately rather than cleaning up the (much larger) mess that we made.

Run your code now and nothing (still!) has changed.

We need to connect the levels to each other.

GOTO 093
</Text>
        </Document>
        <Document ID="19">
            <Title>Function Map</Title>
            <Text>// Global variables
var _game = {};
var _player = {};	
var _levels = [];

function setup() {}

function handle_load(event) {}
function handle_keydown(event) {}
function handle_keyup(event) {}

function init() {}
function init_game() {}

function init_player() {}
function init_player_sprite(name, width, height, origin_x, origin_y) {}
function update_player_sprite() {}

function init_level_defaults(level) {}
function init_level0_title() {}
function init_level1() {}
function init_level2() {}
function init_level3() {}

function add_platforms(level, platform_data) {}
function add_default_platforms(level) {}
function add_moving_platforms(level, platform_data) {}
function create_platform(x, y, width, height, pattern) {}

function add_monsters(level, monster_data) {}
function add_projectile_monsters(level, monster_data) {}
function add_eyeball_monsters(level, eyes, pause, open, close) {}
function create_monster(x, y, width, height, min_x, max_x, move_x, images) {}

function add_items(level, item_data) {}
function add_potion_item(level, x, y) {}
function create_item(x, y, width, height, type, image) {}

function create_goal(x, y, next_level) {}

function start_level(level_id) {}
function complete_level(next_level) {}
function lose_life() {}
function adjust_health(amount) {}

function set_transform_xy(ctx, x, y) {}
function set_transform(ctx, obj) {}
function reset_transform(ctx) {}

function draw() {}
function erase(ctx) {}
function draw_platforms(ctx) {}
function draw_monsters(ctx) {}
function draw_items(ctx) {}
function draw_goal(ctx) {}
function draw_player(ctx) {}
function draw_status(ctx) {}

function draw_title_screen() {}
function draw_transition_screen() {}

function update_platforms() {}
function update_monsters() {}
function update_items() {}
function update_player() {}

function check_input() {}

function check_collisions() {}
function check_platform_collisions() {}
function check_monster_collisions() {}
function check_item_collisions() {}
function check_goal_collisions() {}

function collide(obj1, obj2) {}

function update_world() {}

setup();
</Text>
        </Document>
        <Document ID="42">
            <Title>007 Experiment with player size</Title>
            <Synopsis>GOTO 008</Synopsis>
            <Text>Change the width and height of the player and notice how it always rests properly on the platform.

GOTO 008</Text>
        </Document>
        <Document ID="86">
            <Title>091 Cleaning up</Title>
            <Text>Before we add new levels we should streamline the level creation code so that it is easy to create new levels.

"streamline" and "clean up" sound like fancy ways of saying that I'm going to write a lot of code, but I'm not going to see the game get any better.

True, but the code will get better, which will make it easier for you to add more interesting features to the game. If you don't do this, the code will become harder to manage.


We could just copy and paste everything, but that would make future changes more difficult to make.

Things that we know will be the same for every level. currently not much, but we'll be adding more here.

function init_player() {
	...
}

function init_level_defaults(level) {
	level.platforms = [];
	level.monsters = [];
}

function init_level1() {
	...
}

fdafd

function init_level1() {
	var level = {};
	init_level_defaults(level);

	level.platforms = [];
	// The bottom brick platform along the bottom of the stage.
	level.platforms.push(create_platform(0, 360, _game.width, 40));
	// The left offstage 'wall' to keep the player on the stage.
	level.platforms.push(
		create_platform(-60, -_game.height, 60, 2 * _game.height));
	// The right offstage 'wall' to keep the player on the stage.
	level.platforms.push(
		create_platform(_game.width, -_game.height, 60, 2 * _game.height));
	level.platforms.push(create_platform(200, 290, 80, 20));
	level.platforms.push(create_platform(300, 240, 80, 20));
	level.platforms.push(create_platform(400, 170, 80, 20));
	level.platforms.push(create_platform(460, 110, 40, 20));

	level.monsters = [];
	level.monsters.push(create_monster(350, 360, 20, 20, 60, 480, -1.0));
	level.monsters.push(create_monster(400, 360, 20, 20, 60, 480, 0.8));

	level.goal = create_goal(500, 360);
	
	_levels.push(level);
}

Run to make sure everything still works.

fdas

Now let's look at the platform code. very repetitive.  the only thing different are the values that we pass to create_platform each time.  We can simplify by having an array of just those values and looping through them.


Delete the current platform creation code:

function init_level1() {
	...

	// The bottom brick platform along the bottom of the stage.
	level.platforms.push(create_platform(0, 360, _game.width, 40));
	// The left offstage 'wall' to keep the player on the stage.
	level.platforms.push(
		create_platform(-60, -_game.height, 60, 2 * _game.height));
	// The right offstage 'wall' to keep the player on the stage.
	level.platforms.push(
		create_platform(_game.width, -_game.height, 60, 2 * _game.height));
	level.platforms.push(create_platform(200, 290, 80, 20));
	level.platforms.push(create_platform(300, 240, 80, 20));
	level.platforms.push(create_platform(400, 170, 80, 20));
	level.platforms.push(create_platform(460, 110, 40, 20));

	...
}


and replace it with:


function init_level1() {
	...

	var platform_data = [
		// The bottom brick platform along the bottom of the stage.
		[0, 360, _game.width, 40],
		// The left offstage 'wall' to keep the player on the stage.
		[-60, -_game.height, 60, 2 * _game.height],
		// The right offstage 'wall' to keep the player on the stage.
		[_game.width, -_game.height, 60, 2 * _game.height],
		[200, 290, 80, 20],
		[300, 240, 80, 20],
		[400, 170, 80, 20],
		[460, 110, 40, 20],
	];
	for (var i = 0; i &lt; platform_data.length; i++) {
		var p = platform_data[i];
		var plat = create_platform(p[0], p[1], p[2], p[3], p[4]);
		level.platforms.push(plat);
	}

	...
}

The loop to create the platforms from the data is going to be the same for each level, so we can extract that code out into a separate function.


fafd

function init_level1() {
	...
}

// platform_data: [x, y, width, height]
function add_platforms(level, platform_data) {
	for (var i = 0; i &lt; platform_data.length; i++) {
		var p = platform_data[i];
		var plat = create_platform(p[0], p[1], p[2], p[3]);
		level.platforms.push(plat);
	}
}

function create_platform(x, y, width, height) {
	...
}

fdsaf

function init_level1() {
	...

	var platform_data = [
		// The bottom brick platform along the bottom of the stage.
		[0, 360, _game.width, 40],
		// The left offstage 'wall' to keep the player on the stage.
		[-60, -_game.height, 60, 2 * _game.height],
		// The right offstage 'wall' to keep the player on the stage.
		[_game.width, -_game.height, 60, 2 * _game.height],
		[200, 290, 80, 20],
		[300, 240, 80, 20],
		[400, 170, 80, 20],
		[460, 110, 40, 20],
	];
	for (var i = 0; i &lt; platform_data.length; i++) {
		var p = platform_data[i];
		var plat = create_platform(p[0], p[1], p[2], p[3], p[4]);
		level.platforms.push(plat);
	}
	add_platforms(level, platform_data);
	...
}


Run and make sure it works

In addition, the main platform on the bottom and the ones on the left and right side are going to be the same for each level, so we can extract those out into a function as well.

fdas

function add_platforms(level, platform_data) {
	...
}

function add_default_platforms(level) {
	var platform_data = [
		// The bottom brick platform along the bottom of the stage.
		[0, 360, _game.width, 40],
		// The left offstage 'wall' to keep the player on the stage.
		[-60, -_game.height, 60, 2*_game.height],
		// The right offstage 'wall' to keep the player on the stage.
		[_game.width, -_game.height, 60, 2*_game.height],
	];
	add_platforms(level, platform_data);
}

function create_platform(x, y, width, height) {
	...
}

fdasfd

function init_level1() {
	...

	add_default_platforms(level);
	var platform_data = [
		// The bottom brick platform along the bottom of the stage.
		[0, 360, _game.width, 40],
		// The left offstage 'wall' to keep the player on the stage.
		[-60, -_game.height, 60, 2 * _game.height],
		// The right offstage 'wall' to keep the player on the stage.
		[_game.width, -_game.height, 60, 2 * _game.height],
		[200, 290, 80, 20],
		[300, 240, 80, 20],
		[400, 170, 80, 20],
		[460, 110, 40, 20],
	];
	add_platforms(level, platform_data);

	...
}

fdafa

Run and verify

Now we need to do the same thing for the monsters.

The current monster code should be deleted

function init_level1() {
	...

	level.monsters.push(create_monster(350, 360, 20, 20, 60, 480, -1.0));
	level.monsters.push(create_monster(400, 360, 20, 20, 60, 480, 0.8));

	...
}

and replaced with:

function init_level1() {
	...

	var monst = [
		[350, 360, 20, 20, 60, 480, -1.0],
		[400, 360, 20, 20, 60, 480, 0.8],
	];
	add_monsters(level, monst);

	...
}


and we can add

function create_platform(x, y, width, height) {
	...
}

// monster_data: [x, y, width, height, min_x, max_x, move_x]
function add_monsters(level, monster_data) {
	for (var i = 0; i &lt; monster_data.length; i++) {
		var m = monster_data[i];
		var monst = create_monster(m[0], m[1], m[2], m[3], m[4], m[5], m[6]);
		level.monsters.push(monst);
	}
}

function create_monster(x, y, width, height, min_x, max_x, move_x) {
	...
}


one last thing to add is a starting position for the player since each level may want to have the player start in a different location.

function init_level1() {
	var level = {};
	init_level_defaults(level);

	level.player_start_x = 20;
	level.player_start_y = 260;

	add_default_platforms(level);
	var platform_data = [
		[200, 290, 80, 20],
		[300, 240, 80, 20],
		[400, 170, 80, 20],
		[460, 110, 40, 20],
	];
	add_platforms(level, platform_data);

	var monst = [
		[350, 360, 20, 20, 60, 480, -1.0],
		[400, 360, 20, 20, 60, 480, 0.8],
	];
	add_monsters(level, monst);

	level.goal = create_goal(500, 360);
	
	_levels.push(level);
}

We'll use these values when we connect the levels together

run and verify


GOTO 092
</Text>
        </Document>
        <Document ID="107">
            <Title>121 Monster images</Title>
            <Text>Use bitmap images for the monsters


Now do the same thing for monsters

Create the images/monsters directory.

Create 2 icons:
	monsters/vlad.png
	monsters/henrietta.png


fdafdsa

function init_game() {
	...
	_game.imagedir = "images/";
	_game.imagedir_player = _game.imagedir + "player/";
	_game.imagedir_monsters = _game.imagedir + "monsters/";
	...
}


fdas
And now we need to specify which image to use for each monster.


function init_level1() {
	...
	var monst = [
		[350, 360, 20, 20, 60, 480, -1.0, "vlad"],
		[350, 360, 20, 24, 60, 480, -1.0, "vlad"],
		[400, 360, 20, 20, 60, 480, 0.8, "henrietta"],
		[400, 360, 30, 30, 60, 480, 0.8, "henrietta"],
	];
	add_monsters(level, monst);
	...
}

don't forget to update the width and height of each monster. vlad is 20x24 and henrietta is 30x30

fdafd

// monster_data: [x, y, width, height, min_x, max_x, move_x]
// monster_data: [x, y, width, height, min_x, max_x, move_x, image]
function add_monsters(level, monster_data) {
	for (var i = 0; i &lt; monster_data.length; i++) {
		var m = monster_data[i];
		var monst = create_monster(m[0], m[1], m[2], m[3], m[4], m[5], m[6]);
		var monst = create_monster(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);
		level.monsters.push(monst);
	}
}


and finally create_monsters needs to 

function create_monster(x, y, width, height, min_x, max_x, move_x) {
function create_monster(x, y, width, height, min_x, max_x, move_x, images) {
	var m = {};
	m.x = x;
	m.y = y;
	m.width = width;
	m.height = height;
	m.origin_x = m.width / 2;
	m.origin_y = m.height;
	m.min_x = min_x;
	m.max_x = max_x;
	m.move_x = move_x;

	m.sprite.img = new Image();
	msprite.img.src = _game.imagedir_monsters + images + ".png";
	
	return m;
}


fdaa


function draw_monsters(ctx) {
	var level = _levels[_game.current_level];
	var monsters = level.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		ctx.fillStyle = "#800000";
		ctx.fillRect(m.x - m.origin_x, m.y - m.origin_y, m.width, m.height);
		ctx.drawImage(m.img, m.x - m.origin_x, m.y - m.origin_y);
	}
}


fsdfdas

Now you have monsters!
yay!

But they're still walking backwards.

Yes, yes, yes. We'll fix that now.

You earned the "Sprite II - Image" badge.

IF you have the "Treasure II - Finish" badge
THEN GOTO 122

GOTO 100
</Text>
        </Document>
        <Document ID="43">
            <Title>041 Goal first collision</Title>
            <Synopsis>GOTO 031</Synopsis>
            <Text>The goal is displayed, but we want to detect when the player touches the goal.

to do that we need collision detection


fdafsd

function check_input() {
	â€¦
}

function check_collisions() {
	check_goal_collisions();
}

function check_goal_collisions() {
	var goal = _game.goal;
	if (collide(goal, _player)) {
		_game.game_over = true;
	}
}

// This is called ~60 times per second to update the world.
function update_world() {
	update_player();
	check_collisions();
	draw();
	
	requestAnimationFrame(update_world);
}

The only thing missing is the collide() function. We'll add that now.

GOTO 045
</Text>
        </Document>
        <Document ID="115">
            <Title>Stage 6</Title>
        </Document>
        <Document ID="87">
            <Title>093 Connecting the levels</Title>
            <Text>
To connect the levels, we need to modify the goal so that it indicates the next level to go to.

Since we don't have a "game over" level, we'll (temporarily) connect the last level back to the first.

YOU: doesn't that mean that the game will never yet.

B: Yes, but it's only temporary. We'll be adding a proper ending later.


function create_goal(x, y) {
function create_goal(x, y, next_level) {
	var goal = {};
	goal.x = x;
	goal.y = y;
	goal.width = 20;
	goal.height = 20;
	goal.origin_x = goal.width / 2;
	goal.origin_y = goal.height;
	goal.next_level = next_level;
	return goal;
}

and update all the calls:

function init_level1() {
	...
	level.goal = create_goal(500, 360);
	level.goal = create_goal(500, 360, 1);
	...
}

function init_level2() {
	...
	level.goal = create_goal(500, 360);
	level.goal = create_goal(500, 360, 2);
	...
}

function init_level3() {
	...
	level.goal = create_goal(500, 360);
	level.goal = create_goal(500, 360, 0);
	...
}


level1 is at index #0 (_level[0]) and its goal points to level2 (@ index #1)
fd

Add start_level:

function create_goal(x, y, next_level) {
	...
}

function start_level(level_id) {
	_game.current_level = level_id;

	var level = _levels[level_id];
	_player.x = level.player_start_x;
	_player.y = level.player_start_y;
	_player.velocity_x = 0;
	_player.velocity_y = 0;
}

// Erase the stage and draw all the objects.
function draw() {
	...
}

When we start a level, we move the player to the appropriate starting location and remove any velocity they may have from the previous level.
ffda


function check_goal_collisions() {
	var level = _levels[_game.current_level];
	var goal = level.goal;
	if (collide(goal, _player)) {
		_game.game_over = true;
		_game.game_win = true;
		start_level(goal.next_level);
	}
}

Wait, now there's no way to win.

We should also call this after we finish initializing so that the game starts at the correct level.

function handle_load(event) {
	init();
	start_level(0);
	requestAnimationFrame(update_world);
}

don't we already do this in init_game()


Now that we init the player at the start of each level, we no longer need to set x and y in init_player

function init_player() {
	// Player x,y are initialized by the level.
	_player.x = 20;
	_player.x = 0;
	_player.y = _game.height - 40;
	_player.y = 0;

	_player.width = 20;
	_player.height = 20;
	...
}


fdasfd


RUn and verify


GOTO 100
</Text>
        </Document>
        <Document ID="44">
            <Title>043 Goal (after Jumping)</Title>
            <Text>
The goal is displayed, but we want to detect when the player touches the goal.

to do that we need collision detection



function check_collisions() {
	check_platform_collisions();
	check_goal_collisions();
}


and add check_goal_collisions():

function check_platform_collisions() {
	...
}

function check_goal_collisions() {
	var goal = _game.goal;
	if (collide(goal, _player)) {
		_game.game_over = true;
	}
}

// This is called ~60 times per second to update the world.
function update_world() {
	...
}


You already added really simple collision detection for the jumping. We need to switch that over to use this new collide() function.


GOTO 045</Text>
        </Document>
        <Document ID="108">
            <Title>115 Flip direction</Title>
            <Text>We could redraw the images in the other direction and then load both of them and choose the appropriate image based on the direction, but it's tedious to draw each image twice.

It's easier to have the computer flip them for us as needed.

We do that by adding transformations. A transformation changes the coordinate system that we're drawing into.

For example:
origin at top
draw @ 100, 150

or
transform to move origin down to 100, 150
draw @ 0,0

are the same thing. this is called translation since we have simply translated (moved) the origin of the coordinate system.

We can also do a scaling transformation.
If we apply a 2x scale transformation
then drawing a 10x10 box at 100,150 will appear to draw a 20x20 box at 200,300

Negative scales can be used to flip the image.
We need to adjust the origin so that it flips in the correct spot.

Setting the transformation affects all drawing the comes afterward. So we need to set the transform that we want and then restore it to its original.

the canvas context provides functions to save and restore the context, but they are slow because they save the *entire* context font, fillStyle, strokeStyle, transformation and a bunch of other stuff. Since we only need the transform to be saved and restored, we can write our own functions to do this.


Put these before the draw() function:

function set_transform(ctx, obj) {
	var x = obj.x - obj.origin_x;
	var y = obj.y - obj.origin_y;

	// Adjust origin if we're facing left.
	if (obj.dir &lt; 0)
		x += obj.width;

	// Translate origin to (x,y).
	ctx.setTransform(1, 0, 0, 1, x, y);

	// Flip the image if we're facing left.
	if (obj.dir &lt; 0)
		ctx.scale(-1, 1);
}

function reset_transform(ctx) {
	// Reset transform to the identity matrix.
	ctx.setTransform(1, 0, 0, 1, 0, 0);
}

// Erase the stage and draw all the objects.
function draw() {
	...
}

keep track of the current direction for players and monsters

function init_player() {
	...
	_player.origin_y = 0;

	_player.is_jumping = false;
	_player.dir = 1;
	
	_player.velocity_x = 0;
	...
}

and fixup the input:

function check_input() {
	// Left arrow or 'a' to move left.
	if (_game.keymap[37] || _game.keymap[65]) {
		_player.dir = -1;
		_player.velocity_x -= _player.velocity_x_delta;
		if (_player.velocity_x &lt; -_player.velocity_x_max)
			_player.velocity_x = -_player.velocity_x_max;
	}
	// Right arrow or 'd' to move right.
	if (_game.keymap[39] || _game.keymap[68]) {
		_player.dir = 1;
		_player.velocity_x += _player.velocity_x_delta;
		if (_player.velocity_x > _player.velocity_x_max)
			_player.velocity_x = _player.velocity_x_max;
	}
	...
}


fix the player drawing

function draw_player(ctx) {
	var sprite = update_player_sprite();
	set_transform(ctx, _player);
	ctx.drawImage(sprite.img, _player.x - _player.origin_x,
					_player.y - _player.origin_y);
	ctx.drawImage(sprite.img, 0, 0);
	reset_transform(ctx);
}



and now do the same thing for monsters

function create_monster(x, y, width, height, min_x, max_x, move_x, image) {
	...
	m.min_x = min_x;
	m.max_x = max_x;
	m.move_x = move_x;
	m.dir = (move_x > 0) ? 1 : -1;

	m.img = new Image();
	...
}

and. no input but we we need to adjust the code that moves the monsters around.

function update_monsters() {
	var monsters = _levels[_game.current_level].monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		m.x += m.move_x;
		if (m.x &lt;= m.min_x || m.x >= m.max_x) {
			m.move_x *= -1;
			m.dir *= -1;
		}
	}
}

fdas


function draw_monsters(ctx) {
	var level = _levels[_game.current_level];
	var monsters = level.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		set_transform(ctx, m);
		ctx.drawImage(m.img, m.x - m.origin_x, m.y - m.origin_y);
		ctx.drawImage(m.img, 0, 0);
		reset_transform(ctx);
	}
}


fdfdas


You earned the "Sprite III - Direction" badge

GOTO 100</Text>
        </Document>
        <Document ID="88">
            <Title>Stage 5</Title>
        </Document>
        <Document ID="45">
            <Title>042 Game over disable input</Title>
            <Synopsis>GOTO 040</Synopsis>
            <Text>


that's not a very satisfying ending. and the font is kinda ugly there.  

At this point, the game is so simple that there is no sense of accomplishment when you finish the game, but we'll be adding more challenges to make it more interesting.

As for the font, we'll be fixing that later.



player input still works. we should disable it when the game is over
Wrap the check_input() call with a game_over check. Make sure to indent.

function update_player() {
	if (!_game.game_over) {
		check_input();
	}

	// Apply the global world effects on the player.
	_player.velocity_x *= (1.0 - _game.friction);
	...
}



RUN your code in a browser and verify that it loads without errors.

IF you have your "Movement III - Jumping" badge
	THEN GOTO 049
	ELSE GOTO 025


</Text>
        </Document>
        <Document ID="116">
            <Title>200</Title>
            <Text>IF you wan to work on your
		"Transition I - Title"
		"Transition II - Timer"
	badges
	//To work on your "Transition" badges:
	//This will add a title screen and delayed transitions between levels
THEN GOTO 150
</Text>
        </Document>
        <Document ID="89">
            <Title>100 Choices</Title>
            <Text>What would you like to do next?

IF you want to work on your:
		"Sprite II - Image"
		"Sprite III - Direction"
		"Platform III - Pattern"
	badges
	//To work on your "Sprite" and "Platform" badges:
	//This will add bitmap images for the player, monsters, items and platforms
THEN GOTO 110

IF you want to work on your:
		"Vitality I - Health"
		"Vitality II - Reincarnation"
	badges
	//To work on your "Vitality" badges:
	//This will add health and multiple lives
THEN GOTO 170

IF you want to work on your
		"Treasure I - Key"
		"Treasure II - Finish"
		"Treasure III - Potion"  (requires "Vitality I - Health")
	badges
	//To work toward your "Treasure" badges:
	//This will add items (like keys and potions)
THEN GOTO 130



IF you have all of the following badges:	"Treasure III - Potion"
	"Sprite III - Direction"
	"Platform III - Image"
	"Vitality II - Reincarnation"
THEN GOTO 200 "Finish Level 1"
</Text>
        </Document>
        <Document ID="46">
            <Title>029 </Title>
            <Text>We fall off the bottom of the screen! that's because gravity is pulling the player down, but the platform is

We need to add some simple collision with the platform.

IF you have your "Collision I - Basic" badge
	THEN GOTO 027
	ELSE GOTO 026
</Text>
        </Document>
        <Document ID="109">
            <Title>122 Item images</Title>
            <Text>add item images




GOTO 100
</Text>
        </Document>
        <Document ID="47">
            <Title>030 Choice</Title>
        </Document>
        <Document ID="70">
            <Title>056 Monster collisions</Title>
            <Text>The monster is drawn, but you can just walk right through it. That's no fun.

We can update our collision to support monsters.



function check_platform_collisions() {	
	...
}

function check_monster_collisions() {
	var monsters = _game.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		if (collide(m, _player)) {
			_game.game_over = true;
		}
	}
}

function check_goal_collisions() {
	...
}


fdfasdf

and update check_collisions():

function check_collisions() {
	check_platform_collisions();
	check_monster_collisions();
	check_goal_collisions();
}


Now monsters are dangerous. If you collide with it the game will end. But you can easily jump over it at this time.


Adding a second monster is as easy as:

init_game()

	_game.monsters = [];
	_game.monsters.push(create_monster(350, 360, 20, 20));
	_game.monsters.push(create_monster(400, 360, 20, 20));
	_game.goal = create_goal(500, 360);


Gain the "Monster I - Stationary" badge.
GOTO 057

</Text>
        </Document>
        <Document ID="117">
            <Title>139 add key to status bar</Title>
            <Text>draw key in status bar


GOTO 134

</Text>
        </Document>
        <Document ID="48">
            <Title>031 Don't fall off left/right</Title>
            <Text>Now that we have gravity, the simple platform that we created isn't good enough since the player can walk off the edge and fall down forever.

This problem happens offscreen, so we can't see what's happening. but we can see what's going on by shortening the platform.

in init_game()

	// Game state.
	_game.platform = create_platform(0, 360, _game.width, _game.height);
	_game.platform = create_platform(0, 360, 400, _game.height);
	_game.goal = create_goal(500, 360);

now run your code and walk over the edge

If you're fast, you can jump back onto the platform ("falling" is not jumping, so you can get off one last jump). But if you're not, then you fall off and never return.


We can fix this temporarily by adding a check </Text>
        </Document>
        <Document ID="71">
            <Title>057 Win/Lose Message</Title>
            <Text>It's kinda disappointing that winning and losing both result in the same message, so let's change the message based on whether or not the player reaches the goal.


init_game()

	// Game state.
	_game.game_over = false;
	_game.game_win = false;


defad

function check_goal_collisions() {
	var goal = _game.goal;
	if (collide(goal, _player)) {
		_game.game_over = true;
		_game.game_win = true;
	}
}


fdafd

in draw():

	if (_game.game_over) {
		// Dim out the stage by drawing a transparent black rectangle over it.
		ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
		ctx.fillRect(0, 0, _game.width, _game.height);

		ctx.fillStyle = "black";
		ctx.font = "48px Helvetica";
		if (_game.game_win) {
			ctx.fillText("You Win!", 155, 150);
		} else {
			ctx.fillText("Game Over", 140, 150);
		}
	}

fda
fdsa

IF you have "Platform II - Four Sided" badge
	THEN GOTO 061
	ELSE GOTO 060

</Text>
        </Document>
        <Document ID="49">
            <Title>032</Title>
            <Text>and finally, end the jump when we land on a platform.

function check_platform_collisions() {
	if (_player.y > _game.platform.y) {
		_player.is_jumping = false;
		_player.y = _game.platform.y;
		_player.velocity_y = 0;
	}
}


GOTO 034
</Text>
        </Document>
        <Document ID="72">
            <Title>060 Choice</Title>
            <Text>What do you want to do next:

Make monsters move
Add more platforms


IF you have the "Platform II - Four Sided" badge
	GOTO 061


IF you would like to add more platforms, GOTO 070

IF you want to make the monsters move, GOTO 061

</Text>
        </Document>
        <Document ID="73">
            <Title>061 Moving monsters</Title>
            <Text>Let's make the monsters move.



function draw_player(ctx) {
	...
}

function update_monsters() {
	var monsters = _game.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		m.x += m.move_x;
		if (m.x &lt;= m.min_x || m.x >= m.max_x) {
			m.move_x *= -1;
		}
	}
}

// Handle input and move the player.
function update_player() {
	...
}


fdfafd


function update_world() {
	update_monsters();
	update_player();
	check_collisions();
	draw();
	
	requestAnimationFrame(update_world);
}


fdafd


We need to initialize these values:


function create_monster(x, y, width, height) {
function create_monster(x, y, width, height, min_x, max_x, move_x) {
	var m = {};
	m.x = x;
	m.y = y;
	m.width = width;
	m.height = height;
	m.origin_x = m.width / 2;
	m.origin_y = m.height;
	m.min_x = min_x;
	m.max_x = max_x;
	m.move_x = move_x;
	return m;
}


fda

in init_game()

	_game.monsters = [];
	_game.monsters.push(create_monster(350, 360, 20, 20));
	_game.monsters.push(create_monster(350, 360, 20, 20, 60, 480, -1.0));
	_game.monsters.push(create_monster(400, 360, 20, 20));
	_game.monsters.push(create_monster(400, 360, 20, 20, 60, 480, 0.8));


fdafd

GAIN "Monster II - Roaming" badge

IF you have your "Platform II - Four Sided" badge
	THEN GOTO 089
	ELSE GOTO 070


</Text>
        </Document>
        <Document ID="30">
            <Title>015 Friction</Title>
            <Synopsis>BADGE Movement II
GOTO 020</Synopsis>
            <Text>Now that we have the player constrained to move on the main platform, we can start working on the rest of the game.

What was that list of things to do?

YOU: Well, we had Platforms, Jumping, Monsters, â€¦

Oh wait, I just remembered, we should fix the player movement so that player can build up speed and come sliding to a stop.

Why do we need that?

We don't *need* it, but it makes the game far more satisfying to play than simply moving one or two pixels at a time.

It sounds like it's going to be hard. 

It's not. We already have a velocity. We just need to add a maximum velocity and then add some friction.

Friction?

Yes, that will slow you down to a stop.

*** Discussion of velocity and acceleration. ***

function init_game() {
	...
	// The keymap keeps track of which keys are currently being pressed.
	_game.keymap = {};

	// Game state.
	_game.platform = create_platform(0, 360, _game.width, 40);

	// Global world parameters.
	_game.friction = 0.15;
}

delta is the amount that the velocity increases while the movement keys are held down.
max is the maximum allowed velocity.

function init_player() {
	...
	_player.velocity_x = 0;
	_player.velocity_x_delta = 0.8;
	_player.velocity_x_max = 3.5;
	_player.velocity_y = 0;
}

multiply the velocity by (1 - friction). In our case, we're multiplying by 0.85 (= 1 - 0.15) each time we update the game.
This will cause the velocity to slowly decrease based on how much friction we specify. Higher friction values will cause the player to slow down more quickly.

function update_player() {
	check_input();

	// Apply the global world effects on the player.
	_player.velocity_x *= (1.0 - _game.friction);
	
	// Move the player to the new location.
	_player.x += _player.velocity_x;
	_player.y += _player.velocity_y;
}

YOU: But if we keep multiplying by 0.85, the number will keep getting smaller and smaller, but they'll never reach 0. Doesn't that mean that the player will keep sliding forever? 

Mathematically, the velocity won't ever reach 0, but practically once the velocity is less than 0.01 the player won't be moving on the screen anymore.

One more thing we need to do.
Remove reset velocity to 0. add the delta, make sure it doesn't go too high.

function check_input() {
	_player.velocity_x = 0;
	_player.velocity_y = 0;
	
	// Left arrow or 'a' to move left.
	if (_game.keymap[37] || _game.keymap[65]) {
		_player.velocity_x = -1;
		_player.velocity_x -= _player.velocity_x_delta;
		if (_player.velocity_x &lt; -_player.velocity_x_max)
			_player.velocity_x = -_player.velocity_x_max;
	}
	// Right arrow or 'd' to move right.
	if (_game.keymap[39] || _game.keymap[68]) {
		_player.velocity_x = 1;
		_player.velocity_x += _player.velocity_x_delta;
		if (_player.velocity_x > _player.velocity_x_max)
			_player.velocity_x = _player.velocity_x_max;
	}
}


RUN your code in a browser and verify that it loads without errors.
IF it works, THEN gain the "Movement II - Friction" badge

IF you want to experiment with different friction values
	THEN GOTO 16
	ELSE GOTO 20


===============

but that's not quite how we were taught friction in science classâ€¦

How come we can slide off the edge of the screen?

</Text>
        </Document>
        <Document ID="74">
            <Title>075</Title>
            <Text>fd

function draw_platforms(ctx) {
	var platform = _game.platform;
	var platform = _game.platforms[0];
	ctx.fillStyle = "rgb(153, 102, 51)";
	ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
}

fdafd


function check_platform_collisions() {
	if (collide(_game.platform, _player)) {
	if (collide(_game.platforms[0], _player)) {
		_player.is_jumping = false;
		_player.y = _game.platform.y;
		_player.y = _game.platforms[0].y;
		_player.velocity_y = 0;
	}
}

Run. it should be the same.
Note that draw_ and check_collision only check the first (the 0th) element) of the array.

We can add another platform to the array, but it won't work until we iterate through all the elements of the array. WE do that with a for loop.

fd

function draw_platforms(ctx) {
	var platforms = _game.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		var platform = _game.platforms[0];
		var platform = platforms[i];
		ctx.fillStyle = "rgb(153, 102, 51)";
		ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
	}
}

_game.platforms.length is the number of elements in the array.
Note that _game.platforms[0] is changed to _game.platforms[i].

fdafdfdafd

function check_platform_collisions() {
	var platforms = _game.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		if (collide(_game.platforms[0], _player)) {
		if (collide(platforms[i], _player)) {
			_player.is_jumping = false;
			_player.y = _game.platforms[0].y;
			_player.y = platforms[i].y;
			_player.velocity_y = 0;
		}
	}
}

fdafdsafd

Run it again. it should still be the same, but now it's easy to add new platforms.



IF you have the "Monster I - Stationary" badge
	THEN GOTO 079
	ELSE GOTO 071</Text>
        </Document>
        <Document ID="31">
            <Title>020 Choices</Title>
            <Synopsis>GOTO 025
GOTO 030
GOTO 035</Synopsis>
            <Text>
So we have couple of things that we can work on next:

Jumping (and gravity)
Adding goals (to end the game)
Adding images (to replace the colored rectangles)


To make the player jump, GOTO 025

To add a goal for this game, GOTO 040

</Text>
        </Document>
        <Document ID="75">
            <Title>076 More platforms (1st)</Title>
            <Text>
More platforms

We need an array of platforms.

	// Game state.
	_game.game_over = false;
	_game.platform = create_platform(0, 360, _game.width, 40);
	_game.platforms = [];
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	_game.goal = create_goal(500, 360);

fdsafdfdsfdsa

GOTO 075
</Text>
        </Document>
        <Document ID="32">
            <Title>016 More Friction</Title>
            <Text>Play around with different friction values and see how it affects the player movement. The lower the friction, the more the player will slide. At 0.4 the player will stop almost instantly, whereas at 0.01 it will slide halfway across the screen before stopping.

If we wanted to have our game set in an ice world, we could set the friction very low so that the player was constantly sliding around.

After experimenting with different values, reset them back to the ones we had originally. This is important because when we start adding platforms for the player to jump between, the max velocity and friction will affect how the game plays.

What happens if the friction is = 0? or =1.0?

What about a negative number, like -0.15? Player will accelerate instead of slowing down.

of greater than 1? player velocity will oscillate between positive and negative values. Choose a value around 2.5 and the player will appear to split in 2 and fly off both sides of the screen.

GOTO 020

</Text>
        </Document>
        <Document ID="76">
            <Title>077 More platforms (2nd)</Title>
            <Text>
More platforms

Just like we did with the monsters, we need to add an array of platforms.

	// Game state.
	_game.game_over = false;
	_game.game_win = false;
	_game.platform = create_platform(0, 360, _game.width, 40);
	_game.platforms = [];
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	_game.monsters = [];


fdsafdfdsfdsa

GOTO 075
</Text>
        </Document>
        <Document ID="33">
            <Title>025 Jumping</Title>
            <Text>
First define how much gravity there should be in this world:

In init_game():
	// Global world parameters.
	_game.friction = 0.15;
	_game.gravity = 0.5;



We need to set the initial jump velocity and the max allowed velocity for the player

In init_player():
function init_player() {
	...
	_player.velocity_x = 0;
	_player.velocity_x_delta = 0.8;
	_player.velocity_x_max = 3.5;
	_player.velocity_y = 0;
	_player.velocity_y_jump = -10;
	_player.velocity_y_max = 10;
}


We need to apply gravity to the player (just like we did with friction).

In update_player():
	// Apply the global world effects on the player: friction.
	_player.velocity_x *= (1.0 - _game.friction);
	_player.velocity_y += _game.gravity;


and finally check for the jump key to initiate the jump. In this case, Up arrow, 'w' and spacebar:


function check_input() {
	// Left arrow or 'a' to move left.
	if (_game.keymap[37] || _game.keymap[65]) {
		...
	}
	// Right arrow or 'd' to move right.
	if (_game.keymap[39] || _game.keymap[68]) {
		...
	}
	// Up arrow, 'w'  and spacebar to jump.
	if (_game.keymap[38] || _game.keymap[87] || _game.keymap[32]) {
		_player.velocity_y = _player.velocity_y_jump;
	}
}


RUN your code in a browser and verify that it loads without errors.
GOTO 029
</Text>
        </Document>
        <Document ID="77">
            <Title>078 Add 3 more platforms</Title>
            <Text>
Try it out to see how it works.

When you land on the top it works well, but when you hit the bottom or sides, it acts a bit weird. You always jump to the top of the platform.

Indeed, all collisions with the platforms are currently assumed to be at the top.

To fix this, we need to do a better job with our collision detection. In addition to answering the question "did object A collide with object B", we also need to know if object B (the player) collided with the top, bottom, left or right of object A (the platform).

Not surprisingly, this is a bit more complicated than the simple collision detection we did earlier.

But before doing that add a few more platforms:

	_game.platforms = [];
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	_game.platforms.push(create_platform(200, 290, 80, 20));
	_game.platforms.push(create_platform(300, 240, 80, 20));
	_game.platforms.push(create_platform(400, 170, 80, 20));
	_game.platforms.push(create_platform(460, 110, 40, 20));

fdafdsaf

GOTO 072

</Text>
        </Document>
        <Document ID="34">
            <Title>040 Adding goals</Title>
            <Synopsis>GOTO 041</Synopsis>
            <Text>

In init_game():

	// The keymap keeps track of which keys are currently being pressed.
	_game.keymap = {};

	// Game state.
	_game.game_over = false;
	_game.platform = create_platform(0, 360, _game.width, 40);
	_game.goal = create_goal(500, 360);
	
	// Global world parameters.
	_game.friction = 0.15;


Add create_goal:

function init_player() {
	...
}

function create_goal(x, y) {
	var goal = {};
	goal.x = x;
	goal.y = y;
	goal.width = 20;
	goal.height = 20;
	goal.origin_x = goal.width / 2;
	goal.origin_y = goal.height;
	return goal;
}

function draw() {
	...
}





Add:

function draw_platorms(ctx) {
	â€¦
}

function draw_goal(ctx) {
	var goal = _game.goal;
	ctx.fillStyle = "green";
	ctx.fillRect(goal.x - goal.origin_x, goal.y - goal.origin_y,
					goal.width, goal.height);
}

function draw_player(ctx) {
	â€¦
}


And update draw() to call draw_goal()

function draw() {
	var canvas = document.getElementById("stage");
	var ctx = canvas.getContext("2d");

	erase(ctx);
	draw_platforms(ctx);
	draw_goal(ctx);
	draw_player(ctx);
}


xxxx

RUN your code in a browser and verify that it loads without errors.

IF you have your "Movement III - Jumping" badge
	THEN GOTO 043
	ELSE GOTO 041




</Text>
        </Document>
        <Document ID="78">
            <Title>079 Add 2nd (merge)</Title>
            <Text>Adding a second platform

To add a new platform, all we need to do is create a new one and add it to the platforms array.

init_game():

	// Game state.
	_game.game_over = false;
	_game.game_win = false;
	_game.platforms = [];
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	_game.platforms.push(create_platform(200, 290, 80, 20));
	_game.monsters = [];


GOTO 078
</Text>
        </Document>
        <Document ID="35">
            <Title>035 Images</Title>
        </Document>
        <Document ID="79">
            <Title>080</Title>
        </Document>
        <Document ID="36">
            <Title>Common Errors</Title>
            <Text>Pay attention to ':' (color), and the ';' (semi-colon)
	The ':' is non common in JavaScript code, whereas the ';' occurs at the end of each line.

'.' and '_'
	_player.velocity.x is not the same as _player.velocity_x
	_game_width != _game.width

Uncaught SyntaxError: Unexpected end of input
	This usually means that you forgot a closing } in your code.
	Go back to the code you just added and verify that your { and } match.

Uncaught SyntaxError: Unexpected token )
	You have a typo around the area where the unexpected token was encountered.
	Double check all the code in this area (on the line with the error and the line above it).

Uncaught ReferenceError: x is not defined
	The variable 'x' is not defined. This means that you're trying to use a variable that you've never initialized to a value.
	This can be caused by a number of problems:
		Is the variable 'x' the correct name?
		Is the variable 'x' actually initialized anywhere?
		Is there a typo on the line where 'x' is supposed to get initialized?
		If 'x is a function, is the function defined somewhere?

Uncaught TypeError: Cannot read property 'x' of undefined
	There some code like obj.x trying to read property 'x' of object 'obj', but 'obj' is not defined.
	Check to see where 'obj' was supposed to be assigned a value and look for errors there.

Uncaught InvalidStateError: An attempt was made to use an object that is not, or is no longer, usable. 
	This can happen when you try to use an image that not successfully loaded.

Failed to load resource
	This error can occur when the image you specified can't be found.
</Text>
        </Document>
        <Document ID="37">
            <Title>028 Jumping 2</Title>
            <Synopsis>GOTO 032
GOTO 033</Synopsis>
            <Text>
Yay! We can jump.

â€¦sort of...

But if I hold the jump button down, I can fly off the top of the screen.

Yes, apparently you can jump while you're in mid-air, which is not quite what we want. How do you think we should fix that?

You should only be allowed to jump if you're standing on a platform.

So we should add an is_jumping flag to the player to keep track of that.


In init_player():
	_player.origin_x = _player.width / 2;
	_player.origin_y = _player.height;

	_player.is_jumping = false;
	
	_player.velocity_x = 0;
	_player.velocity_x_delta = 0.8;


In check_input():
	// Up arrow, 'w'  and spacebar to jump.
	if (_game.keymap[38] || _game.keymap[87] || _game.keymap[32]) {
		// Only allow jumps when the player is not already jumping.
		if (!_player.is_jumping) {
			_player.is_jumping = true;
			_player.velocity_y = _player.velocity_y_jump;
		}
	}


IF you have your "Collision I - Basic" badge
	THEN GOTO 033
	ELSE GOTO 032

</Text>
        </Document>
        <Document ID="60">
            <Title>Stage 3</Title>
        </Document>
        <Document ID="61">
            <Title>055 Add monsters</Title>
            <Text>
IF you have "Platform II - Four Sided" badge
	THEN GOTO 064
	ELSE GOTO 063



</Text>
        </Document>
        <Document ID="38">
            <Title>xxx Font</Title>
        </Document>
        <Document ID="62">
            <Title>070 Platform arrays</Title>
            <Text>
Want to add more platforms

IF you have the "Monster I - Stationary" badge
	THEN GOTO 077
	ELSE GOTO 076

</Text>
        </Document>
        <Document ID="39">
            <Title>026 Jumping</Title>
            <Text>(first collision code)

Add this basic collision code before your update_world() function:

function check_input() {
	...
}

function check_collisions() {
	check_platform_collisions();
}

function check_platform_collisions() {
	if (_player.y > _game.platform.y) {
		_player.y = _game.platform.y;
		_player.velocity_y = 0;
	}
}

function update_world() {
	update_player();
	check_collisions();
	draw();
	
	requestAnimationFrame(update_world);
}

***Ugly that we hard code 360*** we'll be fixing soon.

And then we need to call this function from our ***

RUN your code in a browser and verify that it loads without errors.

GOTO 028



</Text>
        </Document>
        <Document ID="63">
            <Title>051 Choose</Title>
            <Text>
What do you want to do next?

Add Monsters or More Platforms?


IF you want to add monsters, GOTO 055

IF you want to add More Platforms, GOTO 070

</Text>
        </Document>
        <Document ID="20">
            <Title>001 Choosing a game</Title>
            <Synopsis>GOTO 2</Synopsis>
            <Text>BALTHAZAR: OK. Now that you have your baseline project set up, we can get you started on your game.

BALTHAZAR: What kind of game did you want to create?

Platformer
A platform game or "platformer" is a game where the player jumps from one platform to another to get to a goal.
GOTO 002

YOU: Hmm.. Not much of a choice now is it?  I think maybe I'll do a platformerâ€¦
</Text>
        </Document>
        <Document ID="64">
            <Title>071 Add 2nd</Title>
            <Text>Adding a second platform

To add a new platform, all we need to do is create a new one and add it to the platforms array.

	// Game state.
	_game.game_over = false;
	_game.platforms = [];
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	_game.platforms.push(create_platform(200, 290, 80, 20));
	_game.goal = create_goal(500, 360);

GOTO 078</Text>
        </Document>
        <Document ID="21">
            <Title>Premise</Title>
            <Text>Premise:

Student has to do a project for school.

Wants to do a browser-based game, but doesn't know how to do that.

Was told to come here for help.
</Text>
        </Document>
        <Document ID="65">
            <Title>072 Better Collisions</Title>
            <Text>Change collide() from:


// Return true if the 2 objects overlap.
function collide(obj1, obj2) {
	if ((obj1.x - obj1.origin_x + obj1.width) &lt;= (obj2.x - obj2.origin_x))
		return false;
	if ((obj1.y - obj1.origin_y + obj1.height) &lt;= (obj2.y - obj2.origin_y))
		return false;
	if ((obj2.x - obj2.origin_x + obj2.width) &lt;= (obj1.x - obj1.origin_x))
		return false;
	if ((obj2.y - obj2.origin_y + obj2.height) &lt;= (obj1.y - obj1.origin_y))
		return false;
	
	return true;
}


to:


// If the 2 objects overlap, return a [dx, dy, dir] array containing the x,y
// overlap and the direction of the collision (relative to obj1).
// Return null if they don't overlap.
function collide(obj1, obj2) {
	var o1_center_x = obj1.x - obj1.origin_x + (obj1.width / 2);
	var o1_center_y = obj1.y - obj1.origin_y + (obj1.height / 2);

	var o2_center_x = obj2.x - obj2.origin_x + (obj2.width / 2);
	var o2_center_y = obj2.y - obj2.origin_y + (obj2.height / 2);

	var dx = o1_center_x - o2_center_x;
	var dy = o1_center_y - o2_center_y;
	
	var half_width = (obj1.width + obj2.width) / 2;
	var half_height = (obj1.height + obj2.height) / 2;
	
	// No overlap.
	if (half_width &lt;= Math.abs(dx) || half_height &lt;= Math.abs(dy))
		return null;

	var overlap_x = half_width - Math.abs(dx);
	var overlap_y = half_height - Math.abs(dy);
	
	if (overlap_x >= overlap_y) {
		if (dy > 0)
			return [0, -overlap_y, "top"];
		else
			return [0, overlap_y, "bottom"];
	} else {
		if (dx > 0)
			return [-overlap_x, 0, "left"];
		else
			return [overlap_x, 0, "right"];
	}
}


It now returns an array instead of true/false. Fortunately, JavaScript considers a null array to be false and any valid array to be true.

run the code now and everything should still work like before, but now we have the information we need to make the platforms behave properly.

You earned the "Collision II - Advanced" badge!
GOTO 073

</Text>
        </Document>
        <Document ID="22">
            <Title>002 Starting a platformer</Title>
            <Synopsis>GOTO 3</Synopsis>
            <Text>BALTHAZAR: Before we can start, we need to think about the characteristics that define a platform game. What are the key elements of a platform game?

YOU: Err.. platforms?  (Duh!)

BALTHAZAR: Yes, andâ€¦

YOU: Well, jumping and monsters and treasure andâ€¦

BALTHAZAR: Whoa, we should start making a list since we'll have to add all these things.

YOU: OK, we have:
  * Platforms
  * Jumping
  * Monsters
  * Treasure

BALTHAZAR: Anything else?

YOU: There should be a goal at the end of the game. Oh, and monsters should be able to throw things at you.

BALTHAZAR: So we should add:
  * Goal
  * Projectiles
to our list.

GOTO 003
</Text>
        </Document>
        <Document ID="66">
            <Title>073 Fixing the platforms</Title>
            <Text>Now that we have the collision info, we can fix up the platforms.

To do that we need to change how we handle platform collisions

old:

function check_platform_collisions() {
	var platforms = _game.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		if (collide(platforms[i], _player)) {
			_player.is_jumping = false;
			_player.y = platforms[i].y;
			_player.velocity_y = 0;
		}
	}
}


new:

function check_platform_collisions() {
	var platforms = _game.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		var overlap = collide(platforms[i], _player);
		if (overlap) {
			// Adjust player location so it no longer overlaps with platform.
			_player.x += overlap[0];
			_player.y += overlap[1];

			var dir = overlap[2];
			if (dir == "left" || dir == "right") {
				// Smack into left/right side of platform.
				_player.velocity_x = 0;
			} else if (dir == "top") {
				// Land on top of platform.
				_player.is_jumping = false;
				_player.velocity_y = 0;
			} else {
				// Bounce off bottom of platform.
				_player.velocity_y *= -1;
			}
		}
	}
}




You earned the "Platform II - Four Sided" badge!
GOTO 074</Text>
        </Document>
        <Document ID="23">
            <Title>004 Making the platform work</Title>
            <Synopsis>GOTO 005
GOTO 010</Synopsis>
            <Text>YOU: OK. I have a platform now, but the player still moves all around the screen. How can I make the player stick on the platform?

BALTHAZAR: Well, there're two things we need to do: We need to move the player down so that it starts on the platform, and we also need to constrain the movement so that the player only moves left and right.

YOU: We want to be able to jump, too, right?

BALTHAZAR: Yes, but we'll need to add that back later. Currently, the code handles pressing a button and having the player move up (or down) a pixel. For jumping, we'll have to completely change that code.

YOU: Great. OK, so which of those two things should I do first?

BALTHAZAR: Your choice.


To move the player down onto the platform, GOTO 005

To constrain the player to only move horizontally, GOTO 010
</Text>
        </Document>
        <Document ID="67">
            <Title>074 Better side walls</Title>
            <Text>Now that we have properly behaving platforms, we can add side walls on the left and right and remove our earlier code that constrained the player on the screen.


fdafda

in init_game()

	_game.platforms = [];
	// The bottom brick platform along the bottom of the stage.
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	// The left offstage 'wall' to keep the player on the stage.
	_game.platforms.push(
		create_platform(-60, -_game.height, 60, 2 * _game.height));
	// The right offstage 'wall' to keep the player on the stage.
	_game.platforms.push(
		create_platform(_game.width, -_game.height, 60, 2 * _game.height));
	_game.platforms.push(create_platform(200, 290, 80, 20));
	_game.platforms.push(create_platform(300, 240, 80, 20));
	_game.platforms.push(create_platform(400, 170, 80, 20));
	_game.platforms.push(create_platform(460, 110, 40, 20));

Pay attention: Note that -_game.height looks a bit weird because of the negative sign next to the underscore in _game.



Now, we can remove:

function update_player() {
	...	
	// Move the player to the new location.
	_player.x += _player.velocity_x;
	_player.y += _player.velocity_y;

	if (_player.x &lt; 0) {
		_player.x = 0;
	} else if (_player.x > _game.width) {
		_player.x = _game.width;
	}
}

fdafdsafdf


RUN the code
Note that the player now stays completely on the screen since it's colliding with a tall platform just offscreen.

IF you have your "Monster II - Roaming" badge
	THEN GOTO 089

IF you have your "Monster I - Stationary" badge
	THEN GOTO 061
	ELSE GOTO 055

</Text>
        </Document>
        <Document ID="90">
            <Title>110 Images</Title>
            <Text>IF you do NOT have the "Sprite II - Image" badge:
THEN GOTO 120

ELSE IF you do NOT have the "Sprite III - Direction" badge:
THEN GOTO 115

ELSE IF you do NOT have the "Platform III - Pattern" badge:
THEN GOTO 111

ELSE GOTO 100
</Text>
        </Document>
        <Document ID="24">
            <Title>003 Adding a base platform</Title>
            <Synopsis>BADGE "Platform I"
GOTO 004</Synopsis>
            <Text>BALTHAZAR: Where do you think we should start?

YOU: Since it's a platformer, adding platforms seems like an obvious place to start.

BALTHAZAR: How do you think we can do that?

YOU: By drawing a big rectangle on the screen.

BALTHAZAR: Where?

YOU: At the bottom.

BALTHAZAR: No, I mean where in the code do you do that?

YOU: Oh. Probably in the draw() function.

BALTHAZAR: Good. But rather than adding it directly to the draw() function, we should add a new draw_platforms() function and call that from draw() â€” just like we do for draw_player().

YOU: You mean "draw platforms" with an ess? But we're only drawing one platform.

BALTHAZAR: True, but we'll be adding more platforms soon enough, and we might as well give the function its proper name now so that we don't have to rename it later.

YOU: OK. (Whatever)


function init_player() {
	...
}

function create_platform(x, y, width, height) {
	var p = {};
	p.x = x;
	p.y = y;
	p.width = width;
	p.height = height;
	p.origin_x = 0;
	p.origin_y = 0;	
	return p;
}

function draw() {
	...
}


and in init_game()

	// The keymap keeps track of which keys are currently being pressed.
	_game.keymap = {};

	// Game state.
	_game.platform = create_platform(0, 360, _game.width, 40);



BALTHAZAR: First you should modify the draw() function to call draw_platforms() between the calls to erase() and draw_player():

function draw() {
	var canvas = document.getElementById("stage");
	var ctx = canvas.getContext("2d");

	erase(ctx);
	draw_platforms(ctx);
	draw_player(ctx);
}

BALTHAZAR: And then add the draw_platforms() function just after the erase() function:

// Erase the stage and draw all the objects.
function erase(ctx) {
	...
}

// Draw the platforms.
function draw_platforms(ctx) {
	var platform = _game.platform;
	ctx.fillStyle = "rgb(153, 102, 51)";
	ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
}

// Draw the player.
function draw_player(ctx) {
	...
}

BALTHAZAR: Note that we use the canvas width here. This is so that we can resize the canvas and have the platform stretch to match the width of the canvas.

YOU: Why didn't we do that with the height. We could have used _game.height - 40 instead of 360.

BALTHAZAR: That's an excellent observation. The reason why we use 360 explicitly is because once we start adding more platforms, we need the main platform to stay at 360 even if we make the stage taller. *** We could make all the platforms relative to the bottom of the stage, but that becomes unwieldy.  *** It'll also make some of the following code easier to read. ***

YOU: Oh. OK. So I should try this out now?

BALTHAZAR: Yes, type in the code, try it out and see what happens.

RUN your code in a browser and verify that it loads without errors.
IF it works, THEN gain the "Platform I" badge and GOTO 004
</Text>
        </Document>
        <Document ID="68">
            <Title>Stage 4</Title>
        </Document>
        <Document ID="91">
            <Title>130 Items</Title>
            <Text>
IF you do NOT have the "Treasure I - Key" badge
	GOTO 131

IF you have the "Vitality I - Health" badge
	THEN GOTO 140

GOTO 100
</Text>
        </Document>
        <Document ID="3">
            <Title>Skills</Title>
            <Text>Skill Badges:

Functions
	Return values from functions

Expressions

Arrays

Objects

operators

Variables

if-then-else

For-loops</Text>
        </Document>
        <Document ID="25">
            <Title>005 Move the player onto the platform</Title>
            <Synopsis>GOTO 006</Synopsis>
            <Text>YOU: OK, so let's move the player down onto the platform.

BALTHAZAR: Do you have an idea on how to do that?

YOU: Well, we set the _player.x and _player.y value to 0 in init_player(). We can just change those values can't we?

BALTHAZAR: Correct. What should we change them to?

YOU: I can leave the x value as 0, but I need to change the y value to the top of the platform, which is 360, right?

function init_player() {
	_player.x = 0;
	_player.y = 0;
	_player.y = 360;
	_player.width = 20;
	_player.height = 20;

BALTHAZAR: Let's try that and see what happens.

YOU: Oh, that doesn't sound promising.

RUN your code and GOTO 006
</Text>
        </Document>
        <Document ID="4">
            <Title>Badges</Title>
            <Text>Collision I - Basic (031)
Collision II - Advanced (072)
Monster I - Stationary (056)
Monster II - Roaming (061)
Movement I - Horizontal (010)
Movement II - Friction (015)
Movement III - Jumping (028)  (rename to Gravity?)
Platform I - Base (003)
Platform II - Four Sided (073)
Sprite I - Origin (006)


Platform III - Pattern
Treasure I - Key
Treasure II - Finish
Treasure III - Potion
Sprite II - Image
Sprite III - Direction
Transition I - Title
Transition II - Timer
Vitality I - Health
Vitality II - Reincarnation  (Multiple Lives)

-------

Platform IV - Moving
Treasure IV - Coin
Monster III - Projectile
Sprite IV - Animate
Sprite V - Stateful

Fluff I - Font
Fluff II - Sunglasses
Fluff III - Eyes
</Text>
        </Document>
        <Document ID="69">
            <Title>090</Title>
            <Text>Multiple levels

init_game is getting to be kindofa mess. We should clean that up. and add multiple levels since we're going to need then.

YOU: but we haven't finished the first level yet.

***



Let's add a new _levels global variable.


// Global variables.
var _game = {};
var _player = {};
var _levels = [];

Note the square brackets since _levels is an array.

And copy over the platforms, monsters and goal into a new function called init_level1()

init_game:

	// Game state.
	_game.game_over = false;
	_game.game_win = false;
	_game.platforms = [];
	// The bottom brick platform along the bottom of the stage.
	_game.platforms.push(create_platform(0, 360, _game.width, 40));
	// The left offstage 'wall' to keep the player on the stage.
	_game.platforms.push(
		create_platform(-60, -_game.height, 60, 2 * _game.height));
	// The right offstage 'wall' to keep the player on the stage.
	_game.platforms.push(
		create_platform(_game.width, -_game.height, 60, 2 * _game.height));
	_game.platforms.push(create_platform(200, 290, 80, 20));
	_game.platforms.push(create_platform(300, 240, 80, 20));
	_game.platforms.push(create_platform(400, 170, 80, 20));
	_game.platforms.push(create_platform(460, 110, 40, 20));
	_game.monsters = [];
	_game.monsters.push(create_monster(350, 360, 20, 20, 60, 480, -1.0));
	_game.monsters.push(create_monster(400, 360, 20, 20, 60, 480, 0.8));
	_game.goal = create_goal(500, 360);

**
If you cut and paste, be sure the change all the _game to level.
fff

function init_player() {
	...
}

function init_level1() {
	var level = {};

	level.platforms = [];
	// The bottom brick platform along the bottom of the stage.
	level.platforms.push(create_platform(0, 360, _game.width, 40));
	// The left offstage 'wall' to keep the player on the stage.
	level.platforms.push(
		create_platform(-60, -_game.height, 60, 2 * _game.height));
	// The right offstage 'wall' to keep the player on the stage.
	level.platforms.push(
		create_platform(_game.width, -_game.height, 60, 2 * _game.height));
	level..platforms.push(create_platform(200, 290, 80, 20));
	level.platforms.push(create_platform(300, 240, 80, 20));
	level.platforms.push(create_platform(400, 170, 80, 20));
	level.platforms.push(create_platform(460, 110, 40, 20));

	level.monsters = [];
	level.monsters.push(create_monster(350, 360, 20, 20, 60, 480, -1.0));
	level.monsters.push(create_monster(400, 360, 20, 20, 60, 480, 0.8));

	level.goal = create_goal(500, 360);
	
	_levels.push(level);
}

function create_platform(x, y, width, height) {
	...
}


fdaf

And call this new function from init():

function init() {
	init_game();
	init_player();
	init_level1();
}


fdasf

Since we're creating an array of levels, we need to keep track of the current level.

init_game:

	// Game state.
	_game.game_over = false;
	_game.game_win = false;
	_game.current_level = 0;


We need to 
fdafds
Now we need to fix up all the references to _game.platform, _game.monsters and _game.goal

function draw_platforms(ctx) {
	var level = _levels[_game.current_level];
	var platforms = _game.platforms;
	var platforms = level.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		var platform = platforms[i];
		ctx.fillStyle = "green";
		ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
	}
}

function draw_monsters(ctx) {
	var level = _levels[_game.current_level];
	var monsters = _game.monsters;
	var monsters = level.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		ctx.fillStyle = "#800000";
		ctx.fillRect(m.x - m.origin_x, m.y - m.origin_y, m.width, m.height);
	}
}

function draw_goal(ctx) {
	var level = _levels[_game.current_level];
	var goal = _game.goal;
	var goal = level.goal;
	ctx.fillStyle = "yellow";
	ctx.fillRect(goal.x - goal.origin_x, goal.y - goal.origin_y,
					goal.width, goal.height);
}

function draw_player() {
	...
}

function update_monsters() {
	var level = _levels[_game.current_level];
	var monsters = _game.monsters;
	var monsters = level.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		m.x += m.move_x;
		if (m.x &lt;= m.min_x || m.x >= m.max_x) {
			m.move_x *= -1;
		}
	}
}

fdsafds

function check_platform_collisions() {
	var level = _levels[_game.current_level];
	var platforms = level.platforms;
	var platforms = level.platforms;
	for (var i = 0; i &lt; platforms.length; i++) {
		var overlap = collide(platforms[i], _player);
		if (overlap) {
			...
		}
	}
}

function check_monster_collisions() {
	var level = _levels[_game.current_level];
	var monsters = _game.monsters;
	var monsters = level.monsters;
	for (var i = 0; i &lt; monsters.length; i++) {
		var m = monsters[i];
		if (collide(m, _player)) {
			_game.game_over = true;
		}
	}
}

function check_goal_collisions() {
	var level = _levels[_game.current_level];
	var goal = _game.goal;
	var goal = level.goal;
	if (collide(goal, _player)) {
		_game.game_over = true;
		_game.game_win = true;
	}
}



fdsafs

Run to make sure that everything still works.
Nothing should have changed.


GOTO 091
</Text>
        </Document>
        <Document ID="26">
            <Title>010 Constrain the player movement</Title>
            <Synopsis>BADGE Movement I
GOTO 015
GOTO 005</Synopsis>
            <Text>
"Up, left, down, right when you press the arrow keys. Wait, it should only be able to move left and right for a platformer. So we should start by making it only move left and right."

"Good. And how do we do that?"

YOU: By removing the code that handles up and down keys?

BALTHAZAR: And where is that code?

YOU: It's in the check_input() function. We can just remove the parts that deal with the up arrow and down arrow.

function check_input() {
	_player.x_velocity = 0;
	_player.y_velocity = 0;
	
	// Left arrow or 'a' to move left.
	if (_game.keymap[37] || _game.keymap[65]) {
		_player.x_velocity = -1;
	}
	// Right arrow or 'd' to move right.
	if (_game.keymap[39] || _game.keymap[68]) {
		_player.x_velocity = 1;
	}
	// Up arrow or 'w' to move up.
	if (_game.keymap[38] || _game.keymap[87]) {
		_player.y_velocity = -1;
	}
	// Down arrow or 's' to move up.
	if (_game.keymap[40] || _game.keymap[83]) {
		_player.y_velocity = 1;
	}
}

"Excellent, try that and see what happens."

RUN your code in a browser and verify that it loads without errors.
IF it works, THEN gain the "Movement I" badge

IF you have your "Sprite I - Origin" badge
	THEN GOTO 015
	ELSE GOTO 005
</Text>
        </Document>
        <Document ID="5">
            <Title>Character Sheet</Title>
            <Text>Name
Attributes
Skills
Badges

Function map


"Scholar" class
level progression

Tools and Weapons
	Browser
	Text Editor
	Image Editor

</Text>
        </Document>
        <Document ID="92">
            <Title>250 Transitions</Title>
            <Text>To work on your "Transition" badges:
	GOTO 150
Add title screen
Add transitions between levels
</Text>
        </Document>
        <Document ID="93">
            <Title>170 Vitality</Title>
            <Text>
IF you do NOT have the "Vitality I - Health" badge:
THEN GOTO 180

ELSE IF you do NOT have the "Vitality II - Reincarnation" badge:
THEN GOTO 190

ELSE GOTO 100
</Text>
        </Document>
        <Document ID="6">
            <Title>Potion percentages</Title>
            <Text>

2	132	100		100
2	130	98.48	-
2	128	96.96	97
2	126	95.45	-
4	124	93.93	94
6	120	90.90	91
10	114	86.36	86
12	104	78.78	79
12	92	69.69	70
14	80	60.6	60
14	66	50.0	50
14	52	39.39	40
12	38	28.78	30
12	26	19.69	20
10	14	10.6	10
4	4	3.03	3
0	0	0		0
</Text>
        </Document>
        <Document ID="27">
            <Title>006 Adding player origin</Title>
            <Synopsis>BADGE "Player Origin"
GOTO 007
GOTO 008</Synopsis>
            <Text>Player is drawn under the platform

Because we start drawing from the upper left corner

To properly display the player, we need to subtract the height.

YOU: So, we can just subtract 20 more from y?

We could do that, and it would appear to fix the problem, but what we really want is to be able to specify the player location relative to the bottom (since that's the part that sits on the platform).
That would fix it for now, but what we really want it to specify the player location relative to the bottom middle rather than the upper left.

We need to add an origin in init_player():

	_player.width = 20;
	_player.height = 20;
	_player.origin_x = _player.width / 2;
	_player.origin_y = _player.height;
	
	_player.velocity_x = 0;
	_player.velocity_y = 0;

And then use that origin to calculate the upper-left corner when we need to draw the player.

// Draw the player.
function draw_player(ctx) {
	ctx.fillStyle = "blue";
	ctx.fillRect(_player.x, _player.y, _player.width, _player.height);
	ctx.fillRect(_player.x - _player.origin_x, _player.y - _player.origin_y,
					_player.width, _player.height);
}

Since the origin of the player is now the center, we'll have to adjust the initial x position as well (otherwise the player will be halfway off the screen). The player doesn't have to be exactly at the left edge, so we can just add 20.

function init_player() {
	_player.x = 0;
	_player.x = 20;
	_player.y = 360;


YOU: That sounds like more work than just subtracting the player height.

Yes, but later on we're going to change the size of the player and we're going to be need this change.  

RUN your code in a browser and verify that it loads without errors.
IF it works, THEN gain the "Sprite I - Origin" badge

IF you want to experiment with changing the player width and height
	THEN GOTO 007
	ELSE GOTO 008

</Text>
        </Document>
        <Document ID="50">
            <Title>033</Title>
            <Text>dfdsa

function check_platform_collisions() {
	if (collide(_game.platform, _player)) {
		_player.is_jumping = false;
		_player.y = _game.platform.y;
		_player.velocity_y = 0;
	}
}

fdas

GOTO 034
</Text>
        </Document>
        <Document ID="7">
            <Title>Collision check</Title>
            <Text>//   2                 2  2    2
//   0                 7  8    9
//   0                 6  0    6
//                     +-------+   228
//   +-----------------+--+    |   230
//   |                 |  |    |
//   |                 +--+----+   248
//   +--------------------+        260
// For these 2 objects:
//  dx = 4 = 280 - 276
//  dy = -18 = 230 - 248

shapeA = player
shapeB = block

    // get the vectors to check against
    var vX = (shapeA.x + (shapeA.width / 2)) - (shapeB.x + (shapeB.width / 2)),
        vY = (shapeA.y + (shapeA.height / 2)) - (shapeB.y + (shapeB.height / 2)),

center of player to center of block
vX = (276 + 10) - (200 + 40) = 46
vY = (228 + 10) - (230 + 15) = -7

vX = (280 + 10) - (200 + 40) = 50
vY = (228 + 10) - (230 + 15) = -7

        // add the half widths and half heights of the objects
        hWidths = (shapeA.width / 2) + (shapeB.width / 2),
        hHeights = (shapeA.height / 2) + (shapeB.height / 2),

hWidths = 50
hHeights = 25

        colDir = null;

    // if the x and y vector are less than the half width or half height, they we must be inside the object, causing a collision
    if (Math.abs(vX) &lt; hWidths &amp;&amp; Math.abs(vY) &lt; hHeights) {
        // figures out on which side we are colliding (top, bottom, left, or right)
        var oX = hWidths - Math.abs(vX),
            oY = hHeights - Math.abs(vY);

oX = 50 - 46 = 4
oY = 25 - 7 = 18

        if (oX >= oY) {
            if (vY > 0) {
                colDir = "t";
                shapeA.y += oY;
            } else {
                colDir = "b";
                shapeA.y -= oY;
            }
        } else {
            if (vX > 0) {
                colDir = "l";
                shapeA.x += oX;

player.x += 4

            } else {
                colDir = "r";
                shapeA.x -= oX;
            }
        }
    }
</Text>
        </Document>
        <Document ID="94">
            <Title>145 Potion</Title>
            <Text>Add simple potion


GOTO 130
</Text>
        </Document>
        <Document ID="100">
            <Title>135 Item key</Title>
            <Text>Now that we have support for generic items, we have add different item types the behave differently.

The first item is a key that can be used to unlock the goal.

We have one key on each level that is used to unlock the goal. If the play does not have the key, they will not be able to enter the goal.


function init_level_defaults(level) {
	level.player_has_key = false;

	level.platforms = [];
	level.monsters = [];
	level.items = [];
}

fdasfdsa

function check_item_collisions() {
	var level = _levels[_game.current_level];
	var items = level.items;
	for (var i = 0; i &lt; items.length; i++) {
		var item = items[i];
		if (!item.found) {
			if (collide(item, _player)) {
				if (item.type == "key") {
					level.player_has_key = true;
				}
				item.found = true;
			}
		}
	}
}

adds and only allow the goal to work if the player has the key for this level

function check_goal_collisions() {
	var level = _levels[_game.current_level];
	var goal = level.goal;
	if (collide(goal, _player)) {
	if (collide(goal, _player) &amp;&amp; level.player_has_key) {
		start_level(goal.next_level);
	}
}


fafdasd
with this change, the goal won't work until you get the key.

Unfortunately level 2 doesn't have a key, so you can't get to level 3 anymore.

Gain the "Treasure I - Key" badge

IF you have the "Sprite I - Image" badge
	THEN GOTO 137
	ELSE GOTO 136
</Text>
        </Document>
        <Document ID="8">
            <Title>Previous</Title>
        </Document>
        <Document ID="28">
            <Title>008 Constrain horizontal</Title>
            <Synopsis>GOTO 020
GOTO 010</Synopsis>
            <Text>

But the player can still move all around the screen so we need to fix that now.

</Text>
        </Document>
        <Document ID="51">
            <Title>034</Title>
            <Synopsis>GOTO 040</Synopsis>
            <Text>
RUN your code in a browser and verify that it loads without errors.
IF it works, THEN gain the "Movement III - Jumping" badge

IF you have your "Collision I - Basic" badge
	THEN GOTO 049
	ELSE GOTO 040


</Text>
        </Document>
        <Document ID="9">
            <Title>Keymap</Title>
            <Text>Keymap keep track of which keys are being pressed.

"But what if I'm holding the key down when I start the game?"
It will not be aware of that particular key press until you release it and press it again.</Text>
        </Document>
        <Document ID="95">
            <Title>131 Key</Title>
            <Text>Add key

We'll add a key as an item. and support items just like we do for monsters where we have an array that describes the items that we want to create.


fda

function init_level_defaults(level) {
	level.platforms = [];
	level.monsters = [];
	level.items = [];
}

This initializes all of the levels.


IF you have the "Sprite II - Image" badge,	THEN GOTO 133
	ELSE GOTO 132



</Text>
        </Document>
        <Document ID="29">
            <Title>011</Title>
        </Document>
        <Document ID="52">
            <Title>018 Constrain left/right</Title>
            <Text>The player can still go off the left/right side of the screen.

We'll fix this properly later on, but for now, let's add a simple check in update_player()

function update_player() {
	...
	
	// Move the player to the new location.
	_player.x += _player.velocity_x;
	_player.y += _player.velocity_y;

	if (_player.x &lt; 0) {
		_player.x = 0;
	} else if (_player.x > _game.width) {
		_player.x = _game.width;
	}
}

Because _player.x and _player.y specify the origin of the player, the player can still go partway off-screen, but that's OK for now.

GOTO 020
</Text>
        </Document>
        <Document ID="101">
            <Title>136 level 2-3 - no image</Title>
            <Text>Note that you the goal doesn't indicate whether or not it is currently locked. We'll update that code once we start adding images.


We can add a key to level 2

function init_level2() {
	...
	add_default_platforms(level);

	var items = [
		[250, 360, 20, 20, "key"],
	];
	add_items(level, items);

	level.goal = create_goal(500, 360, 2);
	...
}


fdafd

Rather than add a key to level 3 (which would just allow us to loop back to level 1 in any case), we can add a new item that ends the game when you acquire it.


function init_level3() {
	...
	add_default_platforms(level);

	var items = [
		[500, 360, 20, 20, "finish"],
	];
	add_items(level, items);

	level.goal = create_goal(500, 360, 0);
	
	_levels.push(level);
}


GOTO 138

</Text>
        </Document>
        <Document ID="96">
            <Title>135 Key (with image)</Title>
        </Document>
        <Document ID="53">
            <Title>044</Title>
            <Text>

all the code does so far is set a flag when it detects a collision. hard to tell if it is actually working or not.

We need to show something to the player when the game is over:

function draw() {
	var canvas = document.getElementById("stage");
	var ctx = canvas.getContext("2d");

	erase(ctx);
	draw_platforms(ctx);
	draw_goal(ctx);
	draw_player(ctx);

	if (_game.game_over) {
		// Dim out the stage by drawing a transparent black rectangle over it.
		ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
		ctx.fillRect(0, 0, _game.width, _game.height);

		ctx.fillStyle = "black";
		ctx.font = "48px Helvetica";
		ctx.fillText("Game Over", 140, 150);
	}
}


RUN your code in a browser and verify that it loads without errors.
IF it works, THEN gain the "Collision I - Basic" badge

GOTO 042

</Text>
        </Document>
        <Document ID="10">
            <Title>Baseline</Title>
            <Text>Canvas
	getting the canvas width and height
	drawing into a canvas

handling key input
adding a simple player

HTML and CSS

global vs. local variables
	global are marked with '_'
</Text>
        </Document>
        <Document ID="97">
            <Title>132 Item draw - no image</Title>
            <Text>fda
function init_level1() {
	...
	add_monsters(level, monst);

	var items = [
		[480, 110, 20, 20, "key"],
	];
	add_items(level, items);

	level.goal = create_goal(35, 190, 2);
	
	_levels.push(level);
}

fasfdsafsf


function create_monster(x, y, width, height, min_x, max_x, move_x) {
	...
}

// item_data: [x, y, width, height, type]
function add_items(level, item_data) {
	for (var i = 0; i &lt; item_data.length; i++) {
		var d = item_data[i];
		var item = create_item(d[0], d[1], d[2], d[3], d[4]);
		level.items.push(item);
	}
}

function create_item(x, y, width, height, type) {
	var d = {};
	d.x = x;
	d.y = y;
	d.width = width;
	d.height = height;
	d.origin_x = width / 2;
	d.origin_y = height;
	d.type = type;
	d.found = false;
	return d;
}

function create_goal(x, y, next_level) {
	...
}


Note that d.found is set to false. We'll set this to true so that we know when the item has been found by the player.
fsdafdds

Just having the items on the level isn't enough we need to draw and collide with them.
Nothing will happen 


run verify. code is the same as before.



fdafd

function draw() {
	...
	erase(ctx);
	draw_platforms(ctx);
	draw_monsters(ctx);
	draw_items(ctx);
	draw_goal(ctx);
	draw_player(ctx);
	...
}


fdafd


function draw_monsters(ctx) {
	...
}

function draw_items(ctx) {
	var level = _levels[_game.current_level];
	var items = level.items;
	for (var i = 0; i &lt; items.length; i++) {
		var t = items[i];
		if (!t.found) {
			ctx.fillStyle = "magenta";
			ctx.fillRect(t.x - t.origin_x, t.y - t.origin_y, t.width, t.height);
		}
	}
}

function draw_goal(ctx) {
	...
}


ffdasfd

GOTO 134
</Text>
        </Document>
        <Document ID="54">
            <Title>045 Goal merge with </Title>
        </Document>
    </Documents>
</SearchIndexes>